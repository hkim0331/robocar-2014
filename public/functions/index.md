## 関数

関数が使えないうちはプログラミングはまったく楽しくない。

関数が使えるようになるとプログラムは分かりやすく、作りやすく、改良しやすくなる。

関数を理解するために理解すべきこと:

* 関数の名前 --- どんな名前でその関数は呼び出されるか
* 引数 --- どんな種類の引数をいくつ受け取るか
* 戻り値 ---　関数を実行した結果、どんな種類の情報が得られるか
* 関数を定義するとはどういうことか、どんなふうに定義するか
* 関数を呼び出すとはどういうことか、どんなふうに呼び出せるのか

## 例題: 整数二つのうち、「大きい方はこれ」っていう関数

Cプログラマは以下の三つを考える。

* その関数には関数の働きがわかるよう、 larger という名前をつけよう。
* 「整数二つを受け取る」んだから、関数 larger の引数はふたつ、ともに int だ。ふたつの整数を区別するためにそれぞれ違った名前 x, y で呼ぼう。
* 「大きい方」は整数だ。だから関数 larger の戻り値は整数。

ということで次をプログラムする。

````c
int larger(int x, int y)
{
	if (x > y) {
		return x;
	} else {
		return y;
	}
}

````

プログラムの仕方はただ一通りではなく、次のような定義でもよい。

````c
int larger(int x, int y)
{
	int z;

	if (x > y) {
		z = x;
	} else {
		z = y;
	}
	return z;
}

````

次の書き方もあるが、余裕のある奴だけ覚えればいい。

````c
int larger(int x, int y)
{
	return (x > y) ? x : y;
}
````

関数は{ }の中を上から下へ、左から右へ、
if で分岐したり、for でループしたりしつつ、
Cの決まりにしたがい実行され、
return 文に出会うか、関数定義の末尾に到着すると呼び出しを終了し、
その関数を呼び出した元の関数に戻り値を返す。

ほとんどの関数は、
後ろの方で述べる戻り値 void の関数をのぞき、
関数定義の末尾に到着することはない。

### 関数 larger を呼び出す

関数 larger() を定義したら、
関数が必要とするデータ（引数）を ( ) の中に与え、

````c
larger(3,4);
````

のように呼び出す。呼び出すというのはその関数をコンピュータに計算てもらうということ。

コンピュータはプログラムに書かれた指示通りに動き（計算し）、答えを返してくる。
ほんとに大きい方が返ってくるかどうかはプログラマの責任。
まちがったプログラムからは正しい答えは返ってこない。

返ってきた戻り値を煮るなり焼くなりするのは関数 larger を呼び出したプログラム（関数）の役割になる。
上の例では larger(3,4) は4を返してくるが、
呼び出し側はそれを受け取らず、無視している。
ま、悪いプログラム例だ。

ふつうは、戻り値は別の変数に代入するか、他の関数の引数として利用する。

````c
int main(void)
{
	int a=3;
	int b=4;
	int c;

	c = larger(a,b); // larger(a,b)の戻り値がcに代入される
	printf("c=%d\n",c);
	return 0;
}

````

### c = larger(a,b)って？

c = 4 を「c に 4 を代入する」と読まずに、こう読んだらどうか、
「c に 4 を計算した結果を代入する」。
4 を計算した結果は 4 だ。関数や式を計算して値を求めることを「評価する」という。
「評価する」を使えば、c = 4 は「c に4の評価値を代入する」と読む。

c = larger(a,b) は 「c に larger(a,b) の評価値を代入する」。
larger(a,b) の評価値とはlarger(a,b)が return で返してくる値のことで、
この場合、aとbの大きい方の整数。

もっと細かく言うと、larger(a,b)の評価値は次のように求まる。

1. 引数 a の評価値を求める。
1. 引数 b の評価値を求める。
1. それらの値を larger の定義式に現れる引数（上の例ではx,y)に代入し、
1. larger の { } を実行する。
1. { } 内を実行中に　return に出会ったら、
   return の右の式を評価し、関数の戻り値（評価値）とする。

### なんで関数を定義するか？

便利なことがあるから。

3つの整数の最大値をプリントする関数を、

* 関数 larger を利用しないで、
* 関数 larger を利用して、

書いてみる。
整数 a,b,c は初期値を代入しているが、プログラム実行中に scanf で読ませてもいいだろう。

````c
#include <stdio.h>
int main(void)
{
	int a=10;
	int b=20;
	int c=30;

	if (a>b) {
		if (b>c) {
			printf("%d\n",a);
		} else {
			if (a>c) {
				printf("%d\n",a);
			} else {
				printf("%d\n",c);
			}
		}
	} else {
		if (a>c) {
			printf("%d\n",b);
		} else {
			if (c>b) {
				printf("%d\n",c);
			} else {
				printf("%d\n",b);
			}
		}
	}
}
````

きっとどっかで間違っている。自信なし。

larger を利用してみる。

````c
#include <stdio.h>
int larger(int a, int b)
{
    if (a>b) {
        return a;
    } else {
        return b;
    }
}

int main(void)
{
	int a=10;
	int b=20;
	int c=30;

	printf("%d\n", larger(a, larger(b,c)));
	return 0;
}
````

すっきり！

4つの整数の最大値を求めることが必要になっても、
larger(larger(a,b), larger(c,d))
などと応用が利く。

以下、main にベタ書きせず、できるだけ関数で書いてみよ。

## 例題: 直角三角形？

a, b, cを直角三角形の３辺の長さとする。その３角形は直角三角形かどうかを判定する。

````c
#include <stdio.h>
int larger(int a, int b)
{
	if (a > b) {
		return a;
	} else {
		return b;
	}
}

int max(int a, int b, int c)
{
	return larger(a, larger(b,c)));
}

int main(void)
{
	int a = 10
	int b = 20;
	int c = 30;

	if (a == max(a,b,c)) {
		x = b;
		y = c;
		z = a;
	} else if (b == max(a,b,c)) {
		x = a;
		y = c;
		z = b;
	} else {
		x = a;
		y = b;
		z = c;
	}

	if (x*x+y*y == z*z) {
		printf("直角三角形\n");
	} else {
		printf("直角三角形ではない\n");
	}
	return 0;
}
````

関数 larger() を利用して関数 max() を定義するとこは学習できたか？

### 改良

別のアプローチでプログラムしてみる。
a, b, c の最大値を求めなくても、順番を変え、比較を３回すればいいだろう。

````c
#include <stdio.h>
int sub(int x, int y, int z)
{
	return x*x + y*y == z*z;
}

int is_normal(int x, int y, int z)
{
	return sub(x,y,z) || sub(y,z,x) || sub(z,x,y);
}

int main(void)
{
	int a;
	int b;
	int c;

	//a,b,c には整数を読み込むこと。
	if (is_normal(a,b,c)) {
		printf("直角三角形\n");
	} else {
		printf("直角三角形にならない\n");
	}
	return 0;
}
````

同じ内容ならプログラムが短い方が読みやすい。
関数を書くことでプログラムが短く、読みやすくなる。
タイピングの量も少なくて済む。バグも入りにくくなる。

## 例題: 素数

unsigned int の範囲でできるだけ大きな素数を探し当てよう。
素数は 1 と自分以外、自分を割り切る整数がない数。

* その関数の名前として何がふさわしいだろう？　--- is_prime でどうだ？
* その関数は何を引数にとるべきか？ --- 判定すべき整数 n。問題文に unsigned int の範囲とあるから...
* その関数の戻り値はどんな値とすべきか？ --- C では真はなんだった？偽はなんだった？

ということで、整数nが素数かどうかを判定する関数の書き出しはこんな感じ、

````c
int is_prime(unsigned int n)
````

中身はどうなる？下を見ずに、まず、自分で書いてみれ。

````c
int is_prime(unsigned int n)
{
	int i;

	for(i = 2; i < n; i++) {
		if (n % i == 0) {
			return 0; //素数じゃない。
		} else {
			;
		}
	}
	return 1; //素数だ。
}
````

この関数 is_prime()には小さなバグがある。それはなんでしょう？どう変更すればいい？
考えてみること。君らは考えようとしないのがダメと思う。

is_prime()を呼び出すプログラム、

````c
int main(void)
{
	unsigned int i= 1;

	while (i != 0) {
		if (is_prime(i)) {
			printf("%u is prime\n",i);
		} else {
			;
		}
		i++;
	}
	return 0;
}
````

unsigned int がオーバーフローして0になることを利用する点をのぞいて
素直なプログラムだが、こりゃー大変だ。一番大きな素数が求まるまでに何時間かかるか？

ズルというか、アイデアを絞る。一番大きい数から調べて、最初に見つかった数が答えだ。
また、signed int で -1 となるビットパターンが unsigned int の最大値だったことを上手に使う。
裏技だ。必須ではないが驚くべきでもない。

````c
int main(void)
{
	unsigned int i = -1; // iに代入されるのはマイナスの数ではない。

	while (1) {
		if (is_prime(i)) {
			printf("%u is prime\n",i);
			return 0;
		}
		i--;
	}
	return 0;
}
````

このプログラムはまだ甘ちゃんです。もう少し勉強すれば数100倍速いプログラムにできます。

````
$ time ./prime
4294967295 is not prime
4294967294 is not prime
4294967293 is not prime
4294967292 is not prime
4294967291 is prime

real	0m18.240s
user	0m18.212s
sys	    0m0.010s
````

答え 4294967291 を見つけるのに 18 秒かかっています。

改良プログラム prime2 での実行。

````
$ time ./prime2
4294967295 is not prime
4294967294 is not prime
4294967293 is not prime
4294967292 is not prime
4294967291 is prime

real	0m0.011s
user	0m0.001s
sys	    0m0.001s
````

18.24/0.011 = 約1,600倍の高速化に成功！どんな工夫だったんだろう？
中学生くらいなら説明すれば理解出来るくらいの単純なアイデアです。
考えてみよう。

## 例題: 完全数

完全数とは自分を除く約数の和が自分と等しくなる整数のこと。
映画「博士が愛した数式」に出てくる。
たとえば 6 の自分を除く約数は 1,2,3。 足すと6になるので6は完全数。
そのほか28も完全数。次の完全数はいくつでしょう？できるだけ大きな完全数を見つけなさい。

* 関数の名前は　is_perfect、引数は判定すべき整数 n 、戻り値は0/1で真/偽とする。

````c
int is_perfect(int n)
{
	int sum=0;
	int i;

	for (i=1; i<n; i++) {
		if (n%i == 0) {
			sum += i;
		} else {
			;
		}
	}
	return sum == n;
}
````

* sum は定義時にすぐ0に初期化するのにiは初期化しない。
　その理由はすぐ下で1に初期化するから。
* return sum == n の意味、わかるか？わからない理由が難しいが、
  日本語の能力に欠けているか、自分が何をしようとしているか見失っているんだろうな。
* is_perfect()を速くできるか？これはちょっと難しいかも。

## 例題: FizzBuzz
（未完）

FizzBuzz ゲームをプログラムせよ。

## 例題: guess me!
（未完）

1. 0 < x < n の乱数をコンピュータに作らせる。
1. 人間が入力した数字とその乱数がぴったりだったら人間の勝ち。
1. 入力が違っていたら大きいか小さいかだけ、人間に知らせる。
1. n = 100なら7回以内に当てないと人間の負け。

真の乱数の作り方は難しい。周期の非常に長い周期関数でごまかすのが普通だ。

````c
乱数をごかますプログラム
````

あとは任せた。

人間とコンピュータの役割を逆にしたプログラムも作ってみよう。

## 例題: 100言ったら負けゲーム
（未完）

## 戻り値や引数が void とは？
（未完）

void は ''I have nothing to do.'' の nothing と同じ意味。

戻り値がない関数は本来行儀が悪すぎ。
